//Jameson O'Connor
//jameson7
// Brendan Rejevich
// rejevichb

import java.awt.Color;
import java.util.ArrayList;
import java.util.Random;
import java.util.Iterator;
import tester.*;
import javalib.impworld.*;
import javalib.worldimages.*;

/////////////////////////////


interface IList<T> {

    //foldr for ILists given the function func
    <U> U foldr(IMutableFunc2<T, U> func, U basic);
    //reverse IList
    IList<T> reverse();
    // helper for reverse usind a IList<T> acc which is the accumulator
    IList<T> reverseHelp(IList<T> acc);
    //map over the given IList given the function func
    void map(IMutableFunc<T> func);
    }



//Visitors //////////\\\\\\\\\\\\\\/////////\\\\\\\\\\////////////\\\\\\\\\\\\\////////////////////

class FloodCells implements IMutableFunc<Cell> {
    int waterLevel;

    FloodCells(int waterLevel) {
        this.waterLevel = waterLevel;
    }
    //visitor for Cells
    public void apply(Cell c) {
        c.floodCell(waterLevel);
    }
}


class PlaceCells implements IMutableFunc2<Cell, WorldScene> {
    int waterLevel;

    PlaceCells(int waterLevel) {
        this.waterLevel = waterLevel;

    }
    //visitor for Cells to overlay on world 
    public WorldScene apply(Cell c, WorldScene world1) {
         return c.drawCells(world1, waterLevel);   //Need for case on overlaying and drawCells
    }

}


class MT<T> implements IList<T> {
    
    
    //foldr for ILists given the function func
    public <U> U foldr(IMutableFunc2<T, U> func, U board) {
        return board;
    }
    
    //reverse IList
    public IList<T> reverse() {
        return this;
    }
    
    // helper for reverse usind a IList<T> acc which is the accumulator
    public IList<T> reverseHelp(IList<T> acc) {
        return acc;
    }
    //map over the given IList given the function func
    public void map(IMutableFunc<T> func) {
        return;  // don't do anything, the list is empty and there is nothing to map over
    }
}

class Cons<T> implements IList<T> {
    T first;
    IList<T> rest;
    
    Cons(T first, IList<T> rest) {
        this.first = first;
        this.rest = rest;
    }
    
    //foldr for ILists given the function func
    public <U> U foldr(IMutableFunc2<T, U> func, U basic) {
        return func.apply(this.first, this.rest.foldr(func, basic));
    }
    
    //reverse IList
    public IList<T> reverse() {
        return this.reverseHelp(new MT<T>());
    }
    
    // helper for reverse usind a IList<T> acc which is the accumulator
    public IList<T> reverseHelp(IList<T> acc) {
        return this.rest.reverseHelp(new Cons<T>(this.first, acc));
    }
    //map over the given IList given the function func
    public void map(IMutableFunc<T> func) {
         func.apply(this.first);
         this.rest.map(func);
    }
}    




//Represents a single square of the game area
class Cell {

    // represents absolute height of this cell, in feet
    double height;
    // In logical coordinates, with the origin at the top-left corner of the scren
    int x, y;
    // the four adjacent cells to this one
    Cell left, top, right, bottom;
    // reports whether this cell is flooded or not
    boolean isFlooded;
    
    Cell(double height, int x, int y) {
        this.height = height;
        this.x = x;
        this.y = y;
        this.isFlooded = false;
        this.left = null;
        this.right = null;
        this.top = null;
        this.bottom = null;
    }
    
    
    //track where the water forms a coast with the flooded cells
    boolean isCoastline() {
        return this.left.isFlooded || this.right.isFlooded || 
                this.top.isFlooded || this.bottom.isFlooded;
    }

    
    
    //draws cells on world and controls color based on height 
    public WorldScene drawCells(WorldScene background, int waterHeight) {
        int xPos =  ForbiddenIslandWorld.CELL_SIZE * x;
        int yPos = ForbiddenIslandWorld.CELL_SIZE * y;
          
       
        if (this.isFlooded) {
            background.placeImageXY(new RectangleImage(
                    ForbiddenIslandWorld.CELL_SIZE,
                    ForbiddenIslandWorld.CELL_SIZE,
                    OutlineMode.SOLID,
                    new Color(0, 0, floodedColor(waterHeight) * (float) 0.5)), xPos, yPos); 
            return background;
                    
        }
        else if (this.height < waterHeight) {
            background.placeImageXY(new RectangleImage(
                    ForbiddenIslandWorld.CELL_SIZE,
                    ForbiddenIslandWorld.CELL_SIZE,
                    OutlineMode.SOLID,
                    new Color(this.belowR(waterHeight), this.belowG(waterHeight), 0)), xPos, yPos);
            return background;
        }
        else {
            background.placeImageXY(new RectangleImage(
                    ForbiddenIslandWorld.CELL_SIZE,
                    ForbiddenIslandWorld.CELL_SIZE,
                    OutlineMode.SOLID,
                   new Color(this.startColor(waterHeight), (float) 1 , this.startColor(waterHeight))), xPos, yPos);
            return background;
        }
    }
    
    //Color scheme for flooded cells
    float floodedColor(int waterHeight) {
        return (float) (ForbiddenIslandWorld.ISLAND_HEIGHT - (waterHeight - this.height))
                / ForbiddenIslandWorld.ISLAND_HEIGHT;
    }
    
    //color scheme below red
    float belowR(int waterHeight) {
        return (float) (waterHeight - this.height) / (float) ForbiddenIslandWorld.ISLAND_HEIGHT;
    }
    
    //Color scheme to below green
    float belowG(int waterHeight) {
        return (float) (ForbiddenIslandWorld.ISLAND_HEIGHT - waterHeight) 
                / ForbiddenIslandWorld.ISLAND_HEIGHT;
    }
    
    //Starting color for cells 
    float startColor(int waterHeight) {
        return (float) (this.height - waterHeight) / (float) ForbiddenIslandWorld.ISLAND_HEIGHT;
    }    
}


class OceanCell extends Cell {

    OceanCell(int x, int y) {
        super(0, x, y);
        this.isFlooded = true;
    }

    //Draw all the ocean cells
    public WorldScene drawOCells(WorldScene background, int waterHeight) {
        int xPos = ForbiddenIslandWorld.CELL_SIZE * x;
        int yPos = ForbiddenIslandWorld.CELL_SIZE * y;

        background.placeImageXY(new RectangleImage(
                ForbiddenIslandWorld.CELL_SIZE,
                ForbiddenIslandWorld.CELL_SIZE,
                OutlineMode.SOLID,
                new Color(0, 0, (float) 0.5)), xPos, yPos); 
        return background;
    }
}




class ForbiddenIslandWorld extends World {
    
    // All the cells of the game, including the ocean
    IList<Cell> board;
    // the current height of the ocean
    int waterHeight;
    // Defines an int constant
    static final int CELL_SIZE = 10;
    static final int ISLAND_SIZE = 65;
    static final int ISLAND_HEIGHT = (int) Math.floor(ISLAND_SIZE / 2);  
    static final int WORLD_SIZE = ISLAND_SIZE * CELL_SIZE;

    //A nested array of all the heights on the cells
    ArrayList<ArrayList<Double>> cellHeights;
    //A nested array of all the cells in the world
    ArrayList<ArrayList<Cell>> cellArray;
    
    //Constructor for the entire game
    ForbiddenIslandWorld() {
        this.board = new MT<Cell>();
        this.waterHeight = 0;
        this.cellHeights = new ArrayList<ArrayList<Double>>();
        this.cellArray = new ArrayList<ArrayList<Cell>>();
        this.initRandomMountainH();
        this.buildCellArray();
        this.neighborCells();
        this.createBoard();
    }
    
    //initialize the cell heights of the mountain in the diamond island
    void initMountainH() {
        
        //Manhattan distance controls the size of montains  -> MDist
        //total distance x + y from the center of the board
        for (int r = 0; r < ISLAND_SIZE; r = r + 1) {
            cellHeights.add(new ArrayList<Double>());
            for (int i = 0; i < ISLAND_SIZE; i = i + 1) {
                double MDist = Math.abs((ISLAND_SIZE / 2) - i) + Math.abs((ISLAND_SIZE / 2) - r);
                  
                if (MDist > ISLAND_SIZE) {
                    cellHeights.get(r).add(i, 0.0);
                }
                else {
                    cellHeights.get(r).add(i, ISLAND_HEIGHT - MDist);
                }
            }
        }
    }
   
    
    //initialize cell heights for the random island
    // Again using ManHattan distance
    void initRandomMountainH() {
        for (int r = 0; r < ISLAND_SIZE; r = r + 1) {
            cellHeights.add(new ArrayList<Double>());
            for (int i = 0; i < ISLAND_SIZE; i = i + 1) {
                Random newHeight =  new Random();
                double MDist = Math.abs((ISLAND_SIZE / 2) - i) + Math.abs((ISLAND_SIZE / 2) - r);
                
                if (MDist > ISLAND_SIZE) {
                    cellHeights.get(r).add(i, 0.0);
                }
                else {
                    cellHeights.get(r).add(i, newHeight.nextInt(ISLAND_HEIGHT - 1) + 1.0);  //Needs to be a double
                }
            }
        }
    }
    
    
    // initialize the cell heights of this random terrain island
    void initRandomTerrainH() {
        int lo = 0;
        int mid = (int) Math.floor(ISLAND_SIZE / 2);
        int hi = ISLAND_SIZE - 1;
        
        // initialize all heights to 0.0
        for (int r = 0; r < ISLAND_SIZE; r = r + 1) {
            cellHeights.add(new ArrayList<Double>());
            for (int i = 0; i < ISLAND_SIZE; i = i + 1) {
                cellHeights.get(r).add(0.0);
            }
        }
        
        // initialize center to maximum height
        cellHeights.get(mid).remove(mid);
        cellHeights.get(mid).add(mid, (0.0 + ISLAND_HEIGHT));
        // initialize top middle to 1.0
        cellHeights.get(lo).remove(mid);
        cellHeights.get(lo).add(mid, 1.0);
        // initialize left middle 1.0
        cellHeights.get(mid).remove(0);
        cellHeights.get(mid).add(0, 1.0);
        // initialize right middle to 1.0
        cellHeights.get(mid).remove(hi);
        cellHeights.get(mid).add(hi, 1.0);
        //initialize bottom middle 1.0
        cellHeights.get(hi).remove(mid);
        cellHeights.get(hi).add(mid, 1.0);
    }
    
    
    //sub-division algorithms for creating random terrain.
    void subAlgo(Cell tl, Cell tr, Cell bl, Cell br) {
        double rectArea = (bl.y - tl.y) * (tr.x - tl.x);
        double maxArea = ISLAND_SIZE * ISLAND_SIZE;
        int randShift = new Random().nextInt((int) (rectArea / maxArea) * ISLAND_HEIGHT);
        
        double left = randShift + ((tl.height + bl.height) / 2);
        double top = randShift + (tl.height + tr.height) / 2;
        double right = randShift + (tr.height + br.height) / 2;
        double bot = randShift + (bl.height + br.height) / 2;
        double mid = randShift + (tl.height + tr.height + bl.height + br.height) / 4;
    }
    
    //create new CellArray from the cell heights
    void buildCellArray() {
        for (int r = 0; r < ISLAND_SIZE; r = r + 1) {
            cellArray.add(new ArrayList<Cell>());
            for (int i = 0; i < ISLAND_SIZE; i = i + 1) {
                double newHeight = cellHeights.get(r).get(i);
                
                if (newHeight > 0) {
                    cellArray.get(r).add(new Cell(newHeight, i, r));
                    
                }
                else {
                    cellArray.get(r).add(new OceanCell(i, r));
                }
            }
        } 
    }
    
    
    // assign neighbors to created cells in the array
    void neighborCells() {
        for (ArrayList<Cell> loC : cellArray) {
            for (Cell cell : loC) {
                // assign left neighbor
                if (cell.x == 0) {
                    cell.left = cell; 
                    }
                else {
                    cell.left = loC.get(cell.x - 1); 
                    }
                // assign right neighbor
                if (cell.x == ISLAND_SIZE - 1) {
                    cell.right = cell; 
                    }
                else { 
                    cell.right = loC.get(cell.x + 1);
                    }
                // assign top neighbor
                if (cell.y == 0) {
                    cell.top = cell; 
                    }
                else { 
                    cell.top = loC.get(cell.y - 1);
                    }
                // assign bottom neighbor
                if (cell.y == ISLAND_SIZE - 1) {
                    cell.bottom = cell; 
                    }
                else { 
                    cell.bottom = loC.get(cell.y + 1);
                    }
                }
            }
        }
    
    
    
    //convert the cell array to the world and game board 
    void createBoard() {
        for (int r = 0; r < ISLAND_SIZE; r = r + 1) {
            for (int i = 0; i < ISLAND_SIZE; i = i + 1) {
                this.board = new Cons<Cell>(cellArray.get(r).get(i), this.board);
            }
        }
    }
    
 
    public WorldScene makeScene() {
        WorldScene background = new WorldScene(WORLD_SIZE, WORLD_SIZE);
        
        
        for(int r = 0; r<= WORLD_SIZE; r = r + 1) {
            for (int i = 0; i <= WORLD_SIZE; i = i + 1) {
                background = cellArray.get(r).get(i).drawCells(background, this.waterHeight);
            }
        }
        return background;
    }
    
    public void onTick() {
        this.waterHeight = this.waterHeight + 1;
        //this.board.map(new FloodCells(this.waterHeight));
    }

}
   




    class ExamplesIslands {
        
        void testGame(Tester t) {
            ForbiddenIslandWorld world = new ForbiddenIslandWorld();
            world.bigBang(ForbiddenIslandWorld.WORLD_SIZE, ForbiddenIslandWorld.WORLD_SIZE, 1);
        }  
}
