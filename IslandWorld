import java.util.ArrayList;
import java.util.Iterator;
import tester.*;
import javalib.impworld.*;
import java.awt.Color;
import javalib.worldimages.*;



/*
//Represents the ability to produce a sequence of values
//of type T, one at a time
interface Iterator<T> {
    // Does this sequence have at least one more value?
    boolean hasNext();
    // Get the next value in this sequence
    // EFFECT: Advance the iterator to the subsequent value
    T next();
    // EFFECT: Remove the item just returned by next()
    // NOTE: This method may not be supported by every iterator; ignore it for now
    void remove();
}
*/
class ArrayListIterator<T> implements Iterator<T> {
    // the list of items that this iterator iterates over
    ArrayList<T> items;
    // the index of the next item to be returned
    int nextIdx;
    // Construct an iterator for a given ArrayList
    ArrayListIterator(ArrayList<T> items) {
      this.items = items;
      this.nextIdx = 0;
    }
   
    // In ArrayListIterator
    // Does this sequence (of items in the array list) have at least one more
    // value?
    public boolean hasNext() {
        return this.nextIdx < this.items.size();
    }

    // In ArrayListIterator
    // Get the next value in this sequence
    // EFFECT: Advance the iterator to the subsequent value
    public T next() {
        T answer = this.items.get(this.nextIdx);
        this.nextIdx = this.nextIdx + 1;
        return answer;
    }
   
    public void remove() {
      throw new UnsupportedOperationException("Don't do this!");
    }
  }
/*
//Represents anything that can be iterated over
interface Iterable<T> {
    // Returns an iterator over this collection
    Iterator<T> iterator();
}
*/
// represents an iterator for an IList
class IListIterator<T> implements Iterator<T> {
    IList<T> items;
    IListIterator(IList<T> items) {
      this.items = items;
    }
    
    // In IListIterator
    public boolean hasNext() {
      return this.items.isCons();
    }
    
    // In IListIterator
    public T next() {
      ConsList<T> itemsAsCons = this.items.asCons();
      T answer = itemsAsCons.first;
      this.items = itemsAsCons.rest;
      return answer;
    }
    
    // doesn't perform a function
    public void remove() {
      throw new UnsupportedOperationException("Don't do this!");
    }
  }
  

// List interface
interface IList<T> extends Iterable<T> {

    boolean isCons();
    ConsList<T> asCons();
    Iterator<T> iterator();
}

// represents a non-empty List
class ConsList<T> implements IList<T>{
    T first;
    IList<T> rest;
    
    ConsList(T first, IList<T> rest) {
        this.first = first;
        this.rest = rest;
    }
    
    public boolean isCons() {
        return true;
    }
    
    public ConsList<T> asCons() {
        return this;
    }
  
    public Iterator<T> iterator() {
        return new IListIterator<T>(this);
    }
}

// represents an empty list
class EmptyList<T> implements IList<T> {
    
    public boolean isCons() {
        return false;
    }
    
    public ConsList<T> asCons() {
        throw new RuntimeException("Nah fam.");
    }
    public Iterator<T> iterator() {
        return new IListIterator<T>(this);
    }
    
}

// Represents a single square of the game area
class Cell {
    // represents absolute height of this cell, in feet
    double height;

    // In logical coordinates, with the origin at the 
    // top-left corner of the screen
    int x, y;

    // the four adjacent cells to this one
    Cell left, top, right, bottom;

    // reports whether this cell is flooded or not
    boolean isFlooded;
    
    // to construct a Cell (Cells are initially constructed without connectors)
    Cell(double height, int x, int y, boolean isFlooded) {
        this.height = height;
        this.x = x;
        this.y = y;
        this.isFlooded = isFlooded;
    }
    
    // to draw the Image
    public WorldScene drawCell(WorldScene background, int waterHeight) {
        //represents the size of each cell in the scene
        int cellSize = 10;
            background.placeImageXY(new RectangleImage(cellSize, cellSize, "solid", 
                    this.determineColor(waterHeight)), (x * cellSize) + 5, (y * cellSize) + 5);
        return background;
    }
    
    
    // determines the color for each cell
    public Color determineColor(int waterHeight) {
        int r = 0;
        int g = 0;
        int b = 0;
        if (this.height > waterHeight) {
            r = (int)((this.height/ForbiddenIslandWorld.ISLAND_HEIGHT) * 255);
            g = 150 + (int)((this.height/ForbiddenIslandWorld.ISLAND_HEIGHT) * 105);
            b = (int)((this.height/ForbiddenIslandWorld.ISLAND_HEIGHT) * 255);
            return new Color(r, g, b);
        } 
        else if (waterHeight >= this.height && !this.isFlooded) {
            g = (int)((this.height/waterHeight) * 150);
            r = 150 - g;
            return new Color(r, g, 0);
        }
        else {
            return new Color(0, 0, 255);
        }
    }
}

// to represent the ocean cells in the game
class OceanCell extends Cell {
    OceanCell(double height, int x, int y, boolean isFlooded) {
        super(0, x, y, true);
    }
    
    
}

class ForbiddenIslandWorld extends World { 

    // Defines an int constant
    static final int ISLAND_SIZE = 64;

    // represents the total island height
    static final int ISLAND_HEIGHT = ISLAND_SIZE/2;

    // All the cells of the game, including the ocean
    IList<Cell> board;

    // the current height of the ocean
    int waterHeight;

    // All the heights of the cells in the game
    ArrayList<ArrayList<Double>> cellHeights;

    // Helps to determine each cell's Height
    ArrayList<ArrayList<Cell>> cells;
    
    ForbiddenIslandWorld() {
        this.cellHeights = new ArrayList<ArrayList<Double>>();
        this.cells = new ArrayList<ArrayList<Cell>>();
        this.waterHeight = 0;
        makeHeights();
        heightToCell();
        arrayToIList();
    }

    // to make the cellHeights
    void makeHeights() {
        for (int r = 0; r <= ForbiddenIslandWorld.ISLAND_SIZE; r = r + 1) {
            ArrayList<Double> innerArray = new ArrayList<Double>();
            for (int c = 0; c <= ForbiddenIslandWorld.ISLAND_SIZE; c = c + 1) {
                innerArray.add(ForbiddenIslandWorld.ISLAND_HEIGHT - (Math.abs(32.0 - r) + Math.abs(32.0 - c)));
            }
            cellHeights.add(innerArray);
        }
    }
    
    // to add the connections to the cells
    void connectCells()  {
        for (int r = 0; r <= ForbiddenIslandWorld.ISLAND_SIZE; r = r + 1) {
            for (int c = 0; c <= ForbiddenIslandWorld.ISLAND_SIZE; c = c + 1) {     
                if (r == 0 && c == 0) {
                    this.cells.get(r).get(c).left = this.cells.get(r).get(c);
                    this.cells.get(r).get(c).top = this.cells.get(r).get(c);
                    this.cells.get(r).get(c).right = this.cells.get(r + 1).get(c);
                    this.cells.get(r).get(c).bottom = this.cells.get(r).get(c + 1);
                }
                else if (r == ForbiddenIslandWorld.ISLAND_SIZE && c == 0) {
                    this.cells.get(r).get(c).left = this.cells.get(r - 1).get(c);
                    this.cells.get(r).get(c).top = this.cells.get(r).get(c);
                    this.cells.get(r).get(c).right = this.cells.get(r).get(c);
                    this.cells.get(r).get(c).bottom = this.cells.get(r).get(c + 1);
                }
                else if (r == 0 && c == ForbiddenIslandWorld.ISLAND_SIZE) {
                    this.cells.get(r).get(c).left = this.cells.get(r).get(c);
                    this.cells.get(r).get(c).top = this.cells.get(r).get(c - 1);
                    this.cells.get(r).get(c).right = this.cells.get(r + 1).get(c);
                    this.cells.get(r).get(c).bottom = this.cells.get(r).get(c);
                }
                else if (r == ForbiddenIslandWorld.ISLAND_SIZE &&
                        c == ForbiddenIslandWorld.ISLAND_SIZE) {
                    this.cells.get(r).get(c).left = this.cells.get(r - 1).get(c);
                    this.cells.get(r).get(c).top = this.cells.get(r).get(c - 1);
                    this.cells.get(r).get(c).right = this.cells.get(r).get(c);
                    this.cells.get(r).get(c).bottom = this.cells.get(r).get(c);
                }
                else if (r > 0 && r < ForbiddenIslandWorld.ISLAND_SIZE &&
                        c > 0 && r < ForbiddenIslandWorld.ISLAND_SIZE) {
                    this.cells.get(r).get(c).left = this.cells.get(r - 1).get(c);
                    this.cells.get(r).get(c).top = this.cells.get(r).get(c - 1);
                    this.cells.get(r).get(c).right = this.cells.get(r + 1).get(c);
                    this.cells.get(r).get(c).bottom = this.cells.get(r).get(c + 1);
                }
                else if (r > 0 && r < ForbiddenIslandWorld.ISLAND_SIZE &&
                        c == 0) {
                    this.cells.get(r).get(c).left = this.cells.get(r - 1).get(c);
                    this.cells.get(r).get(c).top = this.cells.get(r).get(c);
                    this.cells.get(r).get(c).right = this.cells.get(r + 1).get(c);
                    this.cells.get(r).get(c).bottom = this.cells.get(r).get(c + 1);
                }
                else if (r > 0 && r < ForbiddenIslandWorld.ISLAND_SIZE &&
                        c == ForbiddenIslandWorld.ISLAND_SIZE) {
                    this.cells.get(r).get(c).left = this.cells.get(r - 1).get(c);
                    this.cells.get(r).get(c).top = this.cells.get(r).get(c - 1);
                    this.cells.get(r).get(c).right = this.cells.get(r + 1).get(c);
                    this.cells.get(r).get(c).bottom = this.cells.get(r).get(c);
                }

                else if (r == 0 && c > 0 && c < ForbiddenIslandWorld.ISLAND_SIZE) {
                    this.cells.get(r).get(c).left = this.cells.get(r).get(c);
                    this.cells.get(r).get(c).top = this.cells.get(r).get(c - 1);
                    this.cells.get(r).get(c).right = this.cells.get(r + 1).get(c);
                    this.cells.get(r).get(c).bottom = this.cells.get(r).get(c + 1);
                }
                else if (r == ForbiddenIslandWorld.ISLAND_SIZE &&
                        c > 0 && c < ForbiddenIslandWorld.ISLAND_SIZE) {
                    this.cells.get(r).get(c).left = this.cells.get(r - 1).get(c);
                    this.cells.get(r).get(c).top = this.cells.get(r).get(c - 1);
                    this.cells.get(r).get(c).right = this.cells.get(r).get(c);
                    this.cells.get(r).get(c).bottom = this.cells.get(r).get(c + 1);
                }
                else {
                    this.cells.get(r).get(c).left = this.cells.get(r - 1).get(c);
                    this.cells.get(r).get(c).top = this.cells.get(r).get(c - 1);
                    this.cells.get(r).get(c).right = this.cells.get(r + 1).get(c);
                    this.cells.get(r).get(c).bottom = this.cells.get(r).get(c + 1);
                }
            }
        }
    }
    
    // to convert cells to board
    void arrayToIList() {
        IList<Cell> temp = new EmptyList<Cell>();
        for (int r = 0; r <= ForbiddenIslandWorld.ISLAND_SIZE; r = r + 1) {
            for (int c = 0; c <= ForbiddenIslandWorld.ISLAND_SIZE; c = c + 1) {
               temp = new ConsList<Cell>(cells.get(r).get(c), temp);
            }
        }
        this.board = temp;
    }
    
    // draws the game
    public WorldScene makeScene() {     
        // represents the background of the world
        // starts off as an empty background
        WorldScene background = 
                new WorldScene(ForbiddenIslandWorld.ISLAND_SIZE, 
                        ForbiddenIslandWorld.ISLAND_SIZE);
        /*        
        for (int r = 0; r <= ForbiddenIslandWorld.ISLAND_SIZE; r = r + 1) {
            for (int c = 0; c <= ForbiddenIslandWorld.ISLAND_SIZE; c = c + 1) {
              background = cells.get(r).get(c).drawCell(background, 
                      this.waterHeight);
            }
        }
        */
        for (Cell c: board) {
            background = c.drawCell(background, waterHeight);
        }
        return background;
    }
     
    // to make cells with the corresponding heights
    void heightToCell() {
        for (int r = 0; r <= ForbiddenIslandWorld.ISLAND_SIZE; r = r + 1) {
            ArrayList<Cell> innerArray = new ArrayList<Cell>();
            for (int c = 0; c <= ForbiddenIslandWorld.ISLAND_SIZE; c = c + 1) {
                if (this.cellHeights.get(r).get(c) <= 0) {
                    innerArray.add(new OceanCell(this.cellHeights.get(r).get(c),
                            r, c, true));
                }
                else {
                    innerArray.add(new Cell(this.cellHeights.get(r).get(c),
                            r, c, false));
                }
            }
            cells.add(innerArray);
        }
    }
}

// to represent a Mountain island with a constant slope
class Mountain {

    // represents the total island height
    int totalIslandHeight = ForbiddenIslandWorld.ISLAND_SIZE/2;

    // All the heights of the cells in the game
    ArrayList<ArrayList<Double>> cellHeights;

    // Helps to determine each cell's Height
    ArrayList<ArrayList<Cell>> cells;
    
    // To produce the cellHeight
    Mountain() {
        for (int r = 0; r <= ForbiddenIslandWorld.ISLAND_SIZE; r = r + 1) {
            ArrayList<Double> innerArray = new ArrayList<Double>();
            for (int c = 0; c <= ForbiddenIslandWorld.ISLAND_SIZE; c = c + 1) {
                innerArray.add(this.totalIslandHeight - (Math.abs(32.0 - c) + (Math.abs(32.0 - r))));
            } 
            cellHeights.add(innerArray);
        }
    }
}

// to represent a diamond Island with random heights
class RandomIsland {
    // represents the total island height
    int totalIslandHeight = ForbiddenIslandWorld.ISLAND_SIZE; 

    // All the heights of the cells in the game
    ArrayList<ArrayList<Double>> cellHeights;

    // Helps to determine each cell's Height
    ArrayList<ArrayList<Cell>> cells;

    RandomIsland() {
        for (int r = 0; r <= ForbiddenIslandWorld.ISLAND_SIZE; r = r + 1) {
            ArrayList<Double> innerArray = new ArrayList<Double>();
            for (int c = 0; c <= ForbiddenIslandWorld.ISLAND_SIZE; c = c + 1) {
                if (Math.abs(32.0 - c) + (Math.abs(32.0 - r)) <= 0) {
                    innerArray.add(0.0);
                }
                else {
                    innerArray.add(Math.random() * this.totalIslandHeight + 1);
                }
            }
            cellHeights.add(innerArray);
        }
    }


}

// to represent a island with randomly generated terrain
class Terrain {

    // represents the total island height
    int totalIslandHeight = ForbiddenIslandWorld.ISLAND_SIZE; 

    // All the heights of the cells in the game
    ArrayList<ArrayList<Double>> cellHeights;

    // Helps to determine each cell's Height
    ArrayList<ArrayList<Cell>> cells;

    Terrain() {
        for (int r = 0; r <= ForbiddenIslandWorld.ISLAND_SIZE + 1; r = r + 1) {
            ArrayList<Double> innerArray = new ArrayList<Double>();
            for (int c = 0; c <= ForbiddenIslandWorld.ISLAND_SIZE + 1; c = c + 1) {
                innerArray.add(Math.random() * this.totalIslandHeight);
            }
            cellHeights.add(innerArray);
        }
    }
}

// represents examples of the game
class ExamplesForbiddenIsland {
    // tests the game
    void testGame(Tester t) {
        ForbiddenIslandWorld f = new ForbiddenIslandWorld();
        f.bigBang(650, 650);
    }
}
